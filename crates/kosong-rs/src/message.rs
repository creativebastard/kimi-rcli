//! Message types for LLM communication.
//!
//! This module defines the core message structures used for chat completions,
//! including support for multi-modal content (text, images, audio, video).

use serde::{Deserialize, Serialize};

/// Represents the role of a message sender in a conversation.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Role {
    /// System instructions that guide the model's behavior.
    System,
    /// Messages from the end user.
    User,
    /// Responses generated by the assistant.
    Assistant,
    /// Tool results returned from function calls.
    Tool,
}

impl Role {
    /// Returns the string representation of the role.
    pub fn as_str(&self) -> &'static str {
        match self {
            Role::System => "system",
            Role::User => "user",
            Role::Assistant => "assistant",
            Role::Tool => "tool",
        }
    }
}

impl std::fmt::Display for Role {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

/// A part of message content, supporting multi-modal inputs.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ContentPart {
    /// Plain text content.
    Text { text: String },
    /// Thinking/reasoning content from the model.
    Think { think: String },
    /// URL to an image resource.
    ImageUrl { image_url: ImageUrl },
    /// URL to an audio resource.
    AudioUrl { audio_url: UrlResource },
    /// URL to a video resource.
    VideoUrl { video_url: UrlResource },
}

impl ContentPart {
    /// Creates a new text content part.
    pub fn text<S: Into<String>>(text: S) -> Self {
        ContentPart::Text { text: text.into() }
    }

    /// Creates a new thinking content part.
    pub fn think<S: Into<String>>(think: S) -> Self {
        ContentPart::Think { think: think.into() }
    }

    /// Creates a new image URL content part.
    pub fn image_url<S: Into<String>>(url: S) -> Self {
        ContentPart::ImageUrl {
            image_url: ImageUrl::new(url),
        }
    }

    /// Creates a new audio URL content part.
    pub fn audio_url<S: Into<String>>(url: S) -> Self {
        ContentPart::AudioUrl {
            audio_url: UrlResource::new(url),
        }
    }

    /// Creates a new video URL content part.
    pub fn video_url<S: Into<String>>(url: S) -> Self {
        ContentPart::VideoUrl {
            video_url: UrlResource::new(url),
        }
    }

    /// Returns the text content if this is a text part, otherwise None.
    pub fn as_text(&self) -> Option<&str> {
        match self {
            ContentPart::Text { text } => Some(text),
            _ => None,
        }
    }

    /// Returns the thinking content if this is a think part, otherwise None.
    pub fn as_think(&self) -> Option<&str> {
        match self {
            ContentPart::Think { think } => Some(think),
            _ => None,
        }
    }
}

impl From<String> for ContentPart {
    fn from(text: String) -> Self {
        ContentPart::text(text)
    }
}

impl From<&str> for ContentPart {
    fn from(text: &str) -> Self {
        ContentPart::text(text)
    }
}

/// Image URL resource with optional detail level.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ImageUrl {
    /// The URL of the image.
    pub url: String,
    /// The detail level for image processing (low, high, or auto).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub detail: Option<String>,
}

impl ImageUrl {
    /// Creates a new image URL resource.
    pub fn new<S: Into<String>>(url: S) -> Self {
        Self {
            url: url.into(),
            detail: None,
        }
    }

    /// Sets the detail level for image processing.
    pub fn with_detail<S: Into<String>>(mut self, detail: S) -> Self {
        self.detail = Some(detail.into());
        self
    }
}

/// Generic URL resource for audio/video content.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct UrlResource {
    /// The URL of the resource.
    pub url: String,
}

impl UrlResource {
    /// Creates a new URL resource.
    pub fn new<S: Into<String>>(url: S) -> Self {
        Self { url: url.into() }
    }
}

/// A message in a conversation.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Message {
    /// The role of the message sender.
    pub role: Role,
    /// The content of the message, which can be a single string or multiple parts.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content: Option<MessageContent>,
    /// Tool calls made by the assistant (only present for assistant messages).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_calls: Option<Vec<ToolCall>>,
    /// The ID of the tool call this message is responding to (only for tool messages).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_call_id: Option<String>,
    /// The name of the tool (only for tool messages).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Content of a message, either a simple string or structured parts.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MessageContent {
    /// A simple text string.
    Text(String),
    /// Multiple content parts (for multi-modal messages).
    Parts(Vec<ContentPart>),
}

impl MessageContent {
    /// Returns the content as a string if it's simple text.
    pub fn as_text(&self) -> Option<&str> {
        match self {
            MessageContent::Text(text) => Some(text),
            _ => None,
        }
    }

    /// Returns the content parts if present.
    pub fn as_parts(&self) -> Option<&[ContentPart]> {
        match self {
            MessageContent::Parts(parts) => Some(parts),
            _ => None,
        }
    }

    /// Converts the content to a string representation.
    pub fn to_text(&self) -> String {
        match self {
            MessageContent::Text(text) => text.clone(),
            MessageContent::Parts(parts) => parts
                .iter()
                .filter_map(|p| p.as_text())
                .collect::<Vec<_>>()
                .join(""),
        }
    }
}

impl std::fmt::Display for MessageContent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.to_text())
    }
}

impl From<String> for MessageContent {
    fn from(text: String) -> Self {
        MessageContent::Text(text)
    }
}

impl From<&str> for MessageContent {
    fn from(text: &str) -> Self {
        MessageContent::Text(text.to_string())
    }
}

impl From<Vec<ContentPart>> for MessageContent {
    fn from(parts: Vec<ContentPart>) -> Self {
        MessageContent::Parts(parts)
    }
}

impl Message {
    /// Creates a new message with the given role and text content.
    pub fn new<S: Into<String>>(role: Role, content: S) -> Self {
        Self {
            role,
            content: Some(MessageContent::Text(content.into())),
            tool_calls: None,
            tool_call_id: None,
            name: None,
        }
    }

    /// Creates a new message with multi-part content.
    pub fn with_parts(role: Role, parts: Vec<ContentPart>) -> Self {
        Self {
            role,
            content: Some(MessageContent::Parts(parts)),
            tool_calls: None,
            tool_call_id: None,
            name: None,
        }
    }

    /// Creates a new system message.
    pub fn system<S: Into<String>>(content: S) -> Self {
        Self::new(Role::System, content)
    }

    /// Creates a new user message.
    pub fn user<S: Into<String>>(content: S) -> Self {
        Self::new(Role::User, content)
    }

    /// Creates a new user message with multi-part content.
    pub fn user_with_parts(parts: Vec<ContentPart>) -> Self {
        Self::with_parts(Role::User, parts)
    }

    /// Creates a new assistant message.
    pub fn assistant<S: Into<String>>(content: S) -> Self {
        Self::new(Role::Assistant, content)
    }

    /// Creates a new tool message.
    pub fn tool<S: Into<String>>(tool_call_id: S, content: S) -> Self {
        Self {
            role: Role::Tool,
            content: Some(MessageContent::Text(content.into())),
            tool_calls: None,
            tool_call_id: Some(tool_call_id.into()),
            name: None,
        }
    }

    /// Creates a new assistant message with tool calls.
    pub fn with_tool_calls(tool_calls: Vec<ToolCall>) -> Self {
        Self {
            role: Role::Assistant,
            content: None,
            tool_calls: Some(tool_calls),
            tool_call_id: None,
            name: None,
        }
    }

    /// Sets the name field for this message.
    pub fn with_name<S: Into<String>>(mut self, name: S) -> Self {
        self.name = Some(name.into());
        self
    }

    /// Returns the text content of the message if available.
    pub fn text(&self) -> Option<String> {
        self.content.as_ref().map(|c| c.to_text())
    }

    /// Returns true if this message contains tool calls.
    pub fn has_tool_calls(&self) -> bool {
        self.tool_calls
            .as_ref()
            .map(|calls| !calls.is_empty())
            .unwrap_or(false)
    }

    /// Returns the tool calls if this is an assistant message with tool calls.
    pub fn tool_calls(&self) -> Option<&[ToolCall]> {
        self.tool_calls.as_deref()
    }
}

/// A tool call made by the assistant.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ToolCall {
    /// The unique identifier for this tool call.
    pub id: String,
    /// The type of the tool call (typically "function").
    #[serde(rename = "type")]
    pub call_type: String,
    /// The function to be called.
    pub function: FunctionCall,
}

impl ToolCall {
    /// Creates a new tool call.
    pub fn new<S: Into<String>>(id: S, name: S, arguments: S) -> Self {
        Self {
            id: id.into(),
            call_type: "function".to_string(),
            function: FunctionCall {
                name: name.into(),
                arguments: arguments.into(),
            },
        }
    }
}

/// A function call within a tool call.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct FunctionCall {
    /// The name of the function to call.
    pub name: String,
    /// The JSON-encoded arguments for the function.
    pub arguments: String,
}

impl FunctionCall {
    /// Parses the arguments as JSON.
    pub fn parse_arguments<T: serde::de::DeserializeOwned>(&self) -> Result<T, serde_json::Error> {
        serde_json::from_str(&self.arguments)
    }
}

/// A partial function call for streaming.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
pub struct FunctionCallPart {
    /// The name of the function (if available).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// A partial chunk of the arguments.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arguments: Option<String>,
}

/// A partial tool call for streaming.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ToolCallPart {
    /// The unique identifier for this tool call.
    pub id: String,
    /// The type of the tool call (typically "function").
    #[serde(rename = "type")]
    pub call_type: String,
    /// The partial function call.
    pub function: FunctionCallPart,
    /// Index for ordering in streaming responses.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index: Option<usize>,
}

impl ToolCallPart {
    /// Creates a new tool call part.
    pub fn new<S: Into<String>>(id: S, call_type: S) -> Self {
        Self {
            id: id.into(),
            call_type: call_type.into(),
            function: FunctionCallPart::default(),
            index: None,
        }
    }

    /// Sets the function name.
    pub fn with_name<S: Into<String>>(mut self, name: S) -> Self {
        self.function.name = Some(name.into());
        self
    }

    /// Sets the function arguments.
    pub fn with_arguments<S: Into<String>>(mut self, args: S) -> Self {
        self.function.arguments = Some(args.into());
        self
    }

    /// Sets the index.
    pub fn with_index(mut self, index: usize) -> Self {
        self.index = Some(index);
        self
    }

    /// Merges another part into this one, accumulating arguments.
    pub fn merge(&mut self, other: &ToolCallPart) {
        if let Some(ref name) = other.function.name {
            self.function.name = Some(name.clone());
        }
        if let Some(ref args) = other.function.arguments {
            if let Some(ref mut existing) = self.function.arguments {
                existing.push_str(args);
            } else {
                self.function.arguments = Some(args.clone());
            }
        }
    }

    /// Checks if this part has a complete function call.
    pub fn is_complete(&self) -> bool {
        self.function.name.is_some() && 
        self.function.arguments.is_some() && 
        !self.function.arguments.as_ref().unwrap().is_empty()
    }

    /// Converts this part to a complete ToolCall if complete.
    pub fn to_tool_call(&self) -> Option<ToolCall> {
        if self.is_complete() {
            Some(ToolCall {
                id: self.id.clone(),
                call_type: self.call_type.clone(),
                function: FunctionCall {
                    name: self.function.name.clone().unwrap_or_default(),
                    arguments: self.function.arguments.clone().unwrap_or_default(),
                },
            })
        } else {
            None
        }
    }
}

/// The result of a tool execution.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ToolResult {
    /// The ID of the tool call this result corresponds to.
    pub tool_call_id: String,
    /// The name of the tool that was called.
    pub name: String,
    /// The result content.
    pub content: String,
    /// Whether the tool execution resulted in an error.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_error: Option<bool>,
}

impl ToolResult {
    /// Creates a new successful tool result.
    pub fn new<S: Into<String>>(tool_call_id: S, name: S, content: S) -> Self {
        Self {
            tool_call_id: tool_call_id.into(),
            name: name.into(),
            content: content.into(),
            is_error: Some(false),
        }
    }

    /// Creates a new error tool result.
    pub fn error<S: Into<String>>(tool_call_id: S, name: S, error: S) -> Self {
        Self {
            tool_call_id: tool_call_id.into(),
            name: name.into(),
            content: error.into(),
            is_error: Some(true),
        }
    }

    /// Converts this tool result into a message.
    pub fn into_message(self) -> Message {
        Message::tool(self.tool_call_id, self.content)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_message_creation() {
        let msg = Message::user("Hello");
        assert_eq!(msg.role, Role::User);
        assert_eq!(msg.text(), Some("Hello".to_string()));
    }

    #[test]
    fn test_system_message() {
        let msg = Message::system("You are helpful");
        assert_eq!(msg.role, Role::System);
        assert_eq!(msg.text(), Some("You are helpful".to_string()));
    }

    #[test]
    fn test_tool_message() {
        let msg = Message::tool("call_123", "result data");
        assert_eq!(msg.role, Role::Tool);
        assert_eq!(msg.tool_call_id, Some("call_123".to_string()));
    }

    #[test]
    fn test_content_part_text() {
        let part = ContentPart::text("Hello");
        assert_eq!(part.as_text(), Some("Hello"));
        assert_eq!(part.as_think(), None);
    }

    #[test]
    fn test_content_part_image() {
        let part = ContentPart::image_url("https://example.com/image.png");
        match part {
            ContentPart::ImageUrl { image_url } => {
                assert_eq!(image_url.url, "https://example.com/image.png");
            }
            _ => panic!("Expected ImageUrl variant"),
        }
    }

    #[test]
    fn test_tool_call_creation() {
        let call = ToolCall::new("call_1", "get_weather", r#"{"city": "NYC"}"#);
        assert_eq!(call.id, "call_1");
        assert_eq!(call.function.name, "get_weather");
        assert_eq!(call.call_type, "function");
    }

    #[test]
    fn test_function_parse_arguments() {
        let call = ToolCall::new("call_1", "get_weather", r#"{"city": "NYC"}"#);
        let args: serde_json::Value = call.function.parse_arguments().unwrap();
        assert_eq!(args["city"], "NYC");
    }

    #[test]
    fn test_tool_result() {
        let result = ToolResult::new("call_1", "get_weather", "Sunny, 72Â°F");
        assert_eq!(result.tool_call_id, "call_1");
        assert_eq!(result.is_error, Some(false));

        let err_result = ToolResult::error("call_2", "get_weather", "Network error");
        assert_eq!(err_result.is_error, Some(true));
    }

    #[test]
    fn test_message_with_tool_calls() {
        let calls = vec![ToolCall::new("call_1", "func1", "{}")];
        let msg = Message::with_tool_calls(calls);
        assert!(msg.has_tool_calls());
        assert_eq!(msg.tool_calls().unwrap().len(), 1);
    }

    #[test]
    fn test_multi_part_content() {
        let parts = vec![
            ContentPart::text("Look at this image: "),
            ContentPart::image_url("https://example.com/image.png"),
        ];
        let msg = Message::user_with_parts(parts);
        assert!(msg.content.as_ref().unwrap().as_parts().is_some());
    }
}
